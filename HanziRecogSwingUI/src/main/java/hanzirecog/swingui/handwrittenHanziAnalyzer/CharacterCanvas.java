/*
 * Copyright (C) 2005 Jordan Kiang
 * jordan-at-hanzirecog.swingui.uicommon.org
 *
 *  Refactorized by I-Tang HIU
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

package hanzirecog.swingui.handwrittenHanziAnalyzer;

import hanzirecog.engine.beans.WrittenCharacter;
import hanzirecog.engine.beans.WrittenPoint;
import hanzirecog.engine.beans.WrittenStroke;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.event.MouseEvent;
import java.util.EventObject;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import javax.swing.JLabel;
import javax.swing.SwingUtilities;
import javax.swing.event.MouseInputListener;

/**
 *
 * 	Refactorized by I-Tang HIU August 2018
 * CharacterCanvas is the Swing component on which that accepts handwriting input.
 * It holds an internal WrittenCharacter instance, which it adds new strokes to when they are input.
 * <p>
 * WrittenCharacters are composed of WrittenStrokes, which the wrap a List of WrittenPoints.  The points
 * are generated by mouse action.  Dragging the mouse while clicked a certain distance
 * will add another point to the current WrittenStroke.  The WrittenPoints of the WrittenStrokes can
 * later be examined to do comparison.
 * <p>
 * It extends JLabel so that subclasses could possibly choose to display some text in the background.
 * This is mostly so that we can trace characters with a Character entry tool.
 */
public class CharacterCanvas extends JLabel implements MouseInputListener {

  // The minimum pixel distance the mouse must be dragged before a new point is added.
  // Making this too small will result in lots of points that need to be analyzed.
  // Making this too large results in halting mouse input with characters composed of lines.
  static private final double MIN_STROKE_SEGMENT_LENGTH = 5.0;

  // The WrittenCharacter that is operated on as mouse input is recorded.
  private WrittenCharacter inputCharacter = new WrittenCharacter();

  // We collect a current stroke of input and add whole strokes at a time to the inputCharacter.
  private WrittenStroke currentStroke;
  // Need to keep track of the previous point as we are building a new WrittenStroke.
  private WrittenPoint previousPoint;

  // The awt.Stroke that is used to paint the lines on the Canvas.
  // An awt.Stroke should not be confused with a WrittenStroke.
  private Stroke paintStroke = new BasicStroke(3.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND);

  // listeners that are notified when a stroke is finished, LinkedHashSet ensures uniqueness, iterates in order.
  private Set strokesListeners = new LinkedHashSet();


  /**
   * Builds a new CharacterCanvas.
   */
  public CharacterCanvas() {

    setOpaque(true);
    setBackground(Color.WHITE);
    addMouseListener(this);    // for MousePressed and MouseReleased
    addMouseMotionListener(this);  // for MouseDragged
  }

  /**
   * Clears the Canvas and resets it for entry of another Character.
   */
  public void clear() {

    inputCharacter.clear();  // wipe the WrittenCharacter of all its WrittenStrokes.
    currentStroke = null;
  }

  /**
   * "Undo" the last stroke added to the character.
   */
  public void undo() {
    inputCharacter.undo();
  }

  /**
   * Getter for the WrittenCharacter.
   * Other components that actually do the analysis will need access to it.
   *
   * @return the WrittenCharacter operated on by this Canvas
   */
  public WrittenCharacter getCharacter() {
    return inputCharacter;
  }

  /**
   * The mouse being pressed signals the beginning of a new WrittenStroke.
   *
   * @see java.awt.event.MouseListener#mousePressed(java.awt.event.MouseEvent)
   */
  public void mousePressed(MouseEvent e) {

    // When run as an applet, the top-level seems to get the focus rather than,
    // a sub-component, and the macros won't work unless a component in the
    // window has the focus.  So we take the focus if the top-level has the focus.
    // We don't always take the focus so that we don't steal the focus if we don't
    // have to.  Surely there is a better way?  How to give initial focus in applet?
    if (SwingUtilities.getRoot(this).isFocusOwner())
      requestFocus();
    previousPoint = new WrittenPoint(e.getX(), e.getY());
  }

  /**
   * We add another WrittenPoint to a WrittenStroke when the mouse has been dragged a certain distance.
   *
   * @see java.awt.event.MouseMotionListener#mouseDragged(java.awt.event.MouseEvent)
   */
  public void mouseDragged(MouseEvent e) {

    WrittenPoint nextPoint = new WrittenPoint(e.getX(), e.getY());
    if (previousPoint != null && previousPoint.distance(nextPoint) >= MIN_STROKE_SEGMENT_LENGTH) {
      // If the mouse has not been dragged a minimal distance, then we ignore this event.
      if (currentStroke == null) {
        // If the current stroke is null, that means that the this is the second point of the stroke.
        // The first point is stored previousPoint.
        // Now that we know that there is a second point we can add both points to a newly initialized stroke.
        currentStroke = new WrittenStroke();
        inputCharacter.expandBoundingBox(previousPoint);
        currentStroke.addPoint(previousPoint);
      }
      // Add the new point to the WrittenStroke, and cycle the previousPoint.
      currentStroke.addPoint(nextPoint);
      previousPoint = nextPoint;
      repaint();
    }
  }

  /**
   * Release of the mouse button indicates that the current stroke has ended.
   *
   * @see java.awt.event.MouseListener#mouseReleased(java.awt.event.MouseEvent)
   */
  public void mouseReleased(MouseEvent e) {

    mouseDragged(e);  // do the same stuff we do when the mouse is dragged
    if (null != currentStroke) {
      // The current stroke will still be null if the mouse wasn't dragged far enough for a new stroke.
      // Add the new WrittenStroke to the WrittenCharacter, and reset input variables.
      inputCharacter.addStroke(currentStroke);
      previousPoint = null;
      currentStroke = null;
      repaint();
    }
    notifyStrokesListeners();
  }

  // unused
  public void mouseClicked(MouseEvent e) {
  }

  public void mouseEntered(MouseEvent e) {
  }

  public void mouseExited(MouseEvent e) {
  }

  public void mouseMoved(MouseEvent e) {
  }

  /**
   * Paints this Canvas.
   * Painting involves painting lines between all the points of a WrittenCharacter.
   *
   * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
   */
  public void paintComponent(Graphics g) {

    super.paintComponent(g);
    // The object passed in is always a Graphics2D, so we can cast it.
    // We need a Graphics2D to set the painting stroke, and to set aliasing hints.
    Graphics2D g2D = (Graphics2D) g;
    g2D.setStroke(paintStroke);
    g2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    if (null != currentStroke)
      // A non-null currentStroke means that a new WrittenStroke is being made (the mouse button is held down).
      // Since the stroke is not yet part of the character, we have to paint it separately.
      paintStroke(currentStroke, g);
    // Paints all the WrittenStrokes that have already been added to the WrittenCharacter.
    paintCharacter(g);
  }

  /**
   * Paint the instance character on the canvas.
   *
   * @param g the Graphics object passed to paintComponent
   */
  protected void paintCharacter(Graphics g) {

    // Just iterate over each of the WrittenStrokes and pass them to a stroke painting method.
    List strokeList = inputCharacter.getStrokes();
    for (Iterator strokeIter = strokeList.iterator(); strokeIter.hasNext(); ) {
      WrittenStroke nextStroke = (WrittenStroke) strokeIter.next();
      paintStroke(nextStroke, g);
    }
  }

  /**
   * Paints the given WrittenStroke on the canvas.
   *
   * @param stroke the WrittenStroke to paint
   * @param g      the Graphics object passed to paintComponent
   */
  protected void paintStroke(WrittenStroke stroke, Graphics g) {

    // To paint a WrittenStroke, we just want to paint lines between each of its WrittenPoints.
    // Paint the strokes in black.
    g.setColor(Color.BLACK);

    // We take it for granted that each WrittenStroke has at least two points.
    // This means we should be able to safely call next() without checking.
    Iterator pointIter = stroke.getPoints().iterator();
    WrittenPoint previousPoint = (WrittenPoint) pointIter.next();
    // Iterate over all the WrittenPoints, drawing lines between the next point and the previous point.
    while (pointIter.hasNext()) {
      WrittenPoint nextPoint = (WrittenPoint) pointIter.next();
      g.drawLine((int) previousPoint.getX(), (int) previousPoint.getY(), (int) nextPoint.getX(), (int) nextPoint.getY());
      previousPoint = nextPoint;
    }
  }

  /**
   * Register the given StrokesListener so that its strokeFinished method
   * will be invoked whenever a new Stroke is added.
   *
   * @param listener the StrokesListener to add
   */
  public void addStrokesListener(StrokesListener listener) {

    if (null != listener)
      synchronized (strokesListeners) {
        strokesListeners.add(listener);
      }
    // No effect if listener is null.
  }

  /**
   * Deregisters the given StrokesListener
   *
   * @param listener the StrokesListener to remove
   */
  public void removeStrokesListener(StrokesListener listener) {

    if (null != listener)
      synchronized (strokesListeners) {
        strokesListeners.remove(listener);
      }
    // No effect if listener is null.
  }

  /**
   * Invokes the strokeFinished method on all registered StrokesListeners.
   */
  private void notifyStrokesListeners() {

    synchronized (strokesListeners) {
      for (Iterator listenerIter = strokesListeners.iterator(); listenerIter.hasNext(); ) {
        StrokesListener nextListener = (StrokesListener) listenerIter.next();
        nextListener.strokeFinished(new StrokeEvent());
      }
    }
  }

  /**
   * Components that want to know when a new stroke has been added will need to implement
   * this interface and register the listener via the addStrokesListener method.
   */
  static public interface StrokesListener {
    public void strokeFinished(StrokeEvent e);
  }

  /**
   * A simple event that serves as the argument for the strokeFinished method.
   */
  public class StrokeEvent extends EventObject {

    private StrokeEvent() {
      // the source is always this canvas.
      super(CharacterCanvas.this);
    }
  }
}

